using NAudio.Midi;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Attune {
    class AkaiFire {

        const string AKAI_FIRE_MIDI_NAME = "FL STUDIO FIRE";

        private readonly Attune attune;
        private readonly MidiIn deviceIn;
        private readonly MidiOut deviceOut;

        private AkaiFire(Attune attune, MidiIn deviceIn, MidiOut deviceOut) {
            this.attune = attune;
            this.deviceIn = deviceIn;
            this.deviceOut = deviceOut;
        }

        internal static (AkaiFire, string) Create(Attune attune) {
            Dictionary<string, int> deviceInList = MidiConnect.listMidiIn();
            Dictionary<string, int> deviceOutList = MidiConnect.listMidiOut();
            if (!deviceInList.ContainsKey(AKAI_FIRE_MIDI_NAME) || !deviceOutList.ContainsKey(AKAI_FIRE_MIDI_NAME)) {
                String inNames = String.Join(", ", deviceInList.Keys);
                String outNames = String.Join(", ", deviceOutList.Keys);
                return (null, "Unable to connect to " + AKAI_FIRE_MIDI_NAME + "\n" +
                    "\nAvailable Midi Ins: " + inNames +
                    "\nAvailable Midi Outs: " + outNames
                );
            }

            attune.Log("\nDevice In Capabilites:");
            MidiInCapabilities deviceInCaps = MidiIn.DeviceInfo(deviceInList[AKAI_FIRE_MIDI_NAME]);
            attune.Log(new List<PropertyInfo>(deviceInCaps.GetType().GetProperties()).Select(p => "\t" + p.Name + ": " + p.GetValue(deviceInCaps).ToString() + "\n").ToArray());
            attune.Log("Device Out Capabilites:");
            MidiOutCapabilities deviceOutCaps = MidiOut.DeviceInfo(deviceOutList[AKAI_FIRE_MIDI_NAME]);
            attune.Log(new List<PropertyInfo>(deviceOutCaps.GetType().GetProperties()).Select(p => "\t" + p.Name + ": " + p.GetValue(deviceOutCaps).ToString() + "\n").ToArray());

            AkaiFire akaiFire = new AkaiFire(
                attune: attune,
                deviceIn: MidiConnect.HandleMidiIn(deviceInList[AKAI_FIRE_MIDI_NAME], (s,e) => attune.OnMessage(e.MidiEvent), attune.OnError, attune.OnSysex),
                deviceOut: MidiConnect.GetMidiOut(deviceOutList[AKAI_FIRE_MIDI_NAME])
            );
            return (akaiFire, "Connected to " + AKAI_FIRE_MIDI_NAME);
        }

        internal void SetPadColor(int x, int y, int color) {
            byte[] msgData =  {
                0x47, 0x7F, 0x43, 0x65, // akai // allcall // fire // write pads
                0x00, 0x04, // payload size
                (byte)(y * 0x10 + x), // Pad index
                (byte)((color >> 17) & 0x7F),// r
                (byte)((color >> 9) & 0x7F), // g
                (byte)((color >> 1) & 0x7F)  // b
            };
            SendSysex(msgData);
        }

        byte b = 0;
        internal void WriteOnScreen() {
            b++;
            if (b >= 0x0F)
                b = 0;
            byte[] msgData =  {
                0x47, 0x7F, 0x43, 0x0E, // akai // allcall // fire // write to screen
                0x00, 0x7C, // payload length high bits // payload length low bits
                0x00, 0x07, // Start 8-pixel band of update // End 8-pixel band of update (here, 8 bands of 8 pixels, i.e. the whole display)
                0x00, 0x7F, // Start colum of update // End column of update
            };
            //byte[] drawMatrix = {
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,

            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //    0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
            //};
            byte[] drawMatrix = {
                1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
                1, 0, 0,  1, 0, 0, 1,  1, 0, 1, 0,  0, 1, 1, 1,
                1, 0, 1,  0, 1, 0, 1,  1, 0, 1, 0,  1, 1, 0, 1,
                1, 0, 1,  1, 1, 0, 1,  1, 0, 1, 0,  0, 0, 0, 1,

                1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
                1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
                1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
                1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
            };
            plotPixel(drawMatrix, b, 0, 1);
            SendSysex(msgData, drawMatrix);
        }

        private void plotPixel(byte[] matrix, int X, int Y, int C) {

            int RemapBit;

            if (X < 128 && Y < 64) {
                // Unwind 128x64 arrangement into a 1024x8 arrangement of pixels.
                X += (ushort)(128 * (Y / 8));
                Y %= 8;
                // Remap by tiling 7x8 block of translated pixels.
                RemapBit = _aBitMutate[Y, X % 7];
                if (C > 0) {
                    matrix[4 + X / 7 * 8 + RemapBit / 7] |= (byte)(1u << (RemapBit % 7));
                } else {
                    matrix[4 + X / 7 * 8 + RemapBit / 7] &= (byte)(~(1u << (RemapBit % 7)));
                }
            }
        }

        internal void SendSysex(params byte[][] msgDatas) {
            deviceOut.SendBuffer(new byte[] { 0xF0 });
            foreach (var msgData in msgDatas)
                deviceOut.SendBuffer(msgData);
            deviceOut.SendBuffer(new byte[] { 0xF7 });
        }

        internal void Close() {
            deviceIn.Close();
            deviceOut.Close();
        }

        //
        //
        //

        //static readonly byte[] _aButtons = new byte[] {
        //  0x23, 0x22, 0x21, 0x20, 0x1F, 0x28, 0x29, 0x2A, 0x2B, 0x2C,
        //  0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35
        //};

        static readonly byte[,] _aBitMutate = {
            { 13,  19,  25,  31,  37,  43,  49 },
            { 0,  20,  26,  32,  38,  44,  50 },
            { 1,   7,  27,  33,  39,  45,  51 },
            { 2,   8,  14,  34,  40,  46,  52 },
            { 3,   9,  15,  21,  41,  47,  53 },
            { 4,  10,  16,  22,  28,  48,  54 },
            { 5,  11,  17,  23,  29,  35,  55 },
            { 6,  12,  18,  24,  30,  36,  42 }
        };

        //static readonly uint[] _aColors =  {
        //    0xFF0000,
        //    0xFFFF00,
        //    0x00FF00,
        //    0x00FFFF,
        //    0x0000F0,
        //    0xFF00FF
        //};

        //static readonly byte[] _aSEGGERBitmap = {
        //    0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00,
        //    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00,
        //    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00,
        //    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3e, 0x7f, 0xcf, 0xff, 0xc0, 0x3c, 0x00, 0xf0, 0x13, 0xe0, 0x27, 0x00, 0x31, 0xf1, 0xfc, 0x00,
        //    0x3c, 0x3f, 0x87, 0xff, 0x80, 0x18, 0x00, 0xe0, 0x03, 0xc0, 0x07, 0x00, 0x31, 0xf1, 0xfc, 0x00,
        //    0x3c, 0x1f, 0x87, 0xff, 0x0f, 0x18, 0xff, 0xc3, 0xc3, 0x87, 0x87, 0x1f, 0xf1, 0xf1, 0xfc, 0x00,
        //    0x3e, 0x1f, 0xc3, 0xff, 0x9f, 0x18, 0xff, 0xc7, 0xe3, 0x0f, 0xc7, 0x3f, 0xf1, 0xf1, 0xfc, 0x00,
        //    0x3f, 0x0f, 0xc1, 0xff, 0xfc, 0x18, 0xff, 0x87, 0x03, 0x1e, 0x07, 0x3f, 0xf1, 0xc1, 0xfc, 0x00,
        //    0x3f, 0x07, 0xe0, 0xff, 0xc0, 0x18, 0x01, 0x8f, 0x03, 0x1e, 0x07, 0x00, 0x70, 0x03, 0xfc, 0x00,
        //    0x3f, 0x83, 0xf0, 0xff, 0x80, 0x78, 0x01, 0x8f, 0xff, 0x1f, 0xff, 0x00, 0x70, 0x01, 0xfc, 0x00,
        //    0x3f, 0xc3, 0xf8, 0x7f, 0x07, 0xf8, 0xff, 0x87, 0xff, 0x0f, 0xff, 0x1f, 0xf1, 0xf1, 0xfc, 0x00,
        //    0x3f, 0xe1, 0xfc, 0x3f, 0x1f, 0x38, 0xff, 0xc7, 0xe7, 0x8f, 0xcf, 0x3f, 0xf1, 0xf1, 0xfc, 0x00,
        //    0x3f, 0xe0, 0xfc, 0x1f, 0x0e, 0x18, 0x7f, 0xc3, 0xc7, 0x87, 0x0f, 0x1f, 0xf1, 0xe1, 0xfc, 0x00,
        //    0x3f, 0xf0, 0x7e, 0x1f, 0x80, 0x38, 0x00, 0xe0, 0x07, 0xc0, 0x0f, 0x00, 0x30, 0x01, 0xfc, 0x00,
        //    0x3f, 0xf8, 0x7f, 0x0f, 0xc0, 0x7c, 0x01, 0xf8, 0x1f, 0xf0, 0x3f, 0x00, 0x38, 0x07, 0xfc, 0x00,
        //    0x3d, 0xfc, 0x3f, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3d, 0xfc, 0x1f, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0xfe, 0x0f, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x7f, 0x0f, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x3f, 0x87, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x3f, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00,
        //    0x3c, 0x1f, 0xc1, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00,
        //    0x3c, 0x0f, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00,
        //    0x3c, 0x07, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x07, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x07, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x07, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x0f, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00,
        //    0x3c, 0x1f, 0xc1, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00,
        //    0x3c, 0x3f, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00,
        //    0x3c, 0x3f, 0x87, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x7f, 0x0f, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0xfe, 0x0f, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3d, 0xfc, 0x1f, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3d, 0xfc, 0x3f, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xf8, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xf0, 0x7e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xe0, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xe1, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xc3, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0x83, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0x07, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0x0f, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3e, 0x1f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x1f, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3c, 0x3f, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3e, 0x7f, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
        //    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00,
        //    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00,
        //    0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00,
        //};


        //static byte[] _aOLEDBitmap = new byte[1175];
        //static byte[] _aUsbBuffer = new byte[1500];


        //class SysexMessage
        //{

        //    List<byte> msg = new List<byte>();

        //    internal SysexMessage()
        //    {
        //        msg.Add(0x04);
        //        msg.Add(0xF0);
        //    }

        //    internal void AddByte(byte b)
        //    {
        //        msg.Add(b);
        //    }

        //    internal void AddBytes(params byte[] bytes)
        //    {
        //        foreach (byte b in bytes)
        //            AddByte(b);
        //    }

        //    internal void End()
        //    {
        //        //if (_MidiIndex == 1)
        //        //{
        //        //    _aMidiBuffer[0] += 0x01;  // Turn 0x?4 to 0x?5
        //        //    _aMidiBuffer[_MidiIndex++] = 0xF7;
        //        //    _aMidiBuffer[_MidiIndex++] = 0x00;
        //        //    _aMidiBuffer[_MidiIndex] = 0x00;
        //        //}
        //        //else if (_MidiIndex == 2)
        //        //{
        //        //    _aMidiBuffer[0] += 0x02;  // Turn 0x?4 to 0x?6
        //        //    _aMidiBuffer[_MidiIndex++] = 0xF7;
        //        //    _aMidiBuffer[_MidiIndex] = 0x00;
        //        //}
        //        //else
        //        //{
        //        AddByte(0x03);  // Turn 0x?4 to 0x?7
        //        AddByte(0xF7);
        //        //}
        //        //USBH_MIDI_WrEvent(hMIDI, USBH_LoadU32BE(&_aMidiBuffer[0]));
        //    }

        //    internal void Send()
        //    {
        //        throw new NotImplementedException();
        //    }
        //}

        //static void _FIRE_SetButtonColor(uint Button, uint Color)
        //{
        //    //SendMidi(0x0BB00000uL + (Button << 8) + Color);
        //}

        ////    R     - Row number (0...3).
        ////    C     - Column number (0...15).
        ////    Color - Color in RGB color format (00.RR.GG.BB).
        //static void _FIRE_SetPadColor(uint R, uint C, uint Color)
        //{
        //    SysexMessage msg = new SysexMessage();
        //    msg.AddBytes(0x47, 0x7F, 0x43, 0x65);         // AKAI, All-Call, Fire, WRITE PADS
        //    msg.AddBytes(0, 4);                           // Payload length: 4 bytes
        //    msg.AddByte((byte)(R * 0x10 + C));            // Pad index
        //    msg.AddByte((byte)((Color >> 17) & 0x7F));    // Red
        //    msg.AddByte((byte)((Color >> 9) & 0x7F));     // Green
        //    msg.AddByte((byte)((Color >> 1) & 0x7F));     // Blue
        //    msg.End();
        //}

        //// Shift  - Byte selection shift (0, 8, 16).
        //// Step   - Step number (0...7) within interpolation sequence.
        //static uint InterpolateColor(ushort Color0, ushort Color1, ushort Shift, ushort Step)
        //{
        //    ushort C0 = (ushort)((Color0 >> Shift) & 0xFF);
        //    ushort C1 = (ushort)((Color1 >> Shift) & 0xFF);
        //    return (uint)(((((C1 - C0) * Step / 8) + C0) & 0xFF) << Shift);
        //}

        ////    Display shifted spectrum on a single row.
        ////    Row    - Row to update (0...3)
        ////    Step   - Spectrum step number.
        //static void _FIRE_DisplaySpectrum(ushort Row, ushort Step)
        //{
        //    ushort Color1;
        //    ushort Color2;
        //    ushort Color;
        //    ushort I;

        //    SysexMessage msg = new SysexMessage();
        //    msg.AddBytes(0x47, 0x7F, 0x43, 0x65);    // AKAI, All-Call, Fire, WRITE PADS
        //    msg.AddBytes(0, 64);                     // Payload length: 64 bytes
        //    for (I = 0; I < 16; ++I)
        //    {
        //        Color1 = (ushort)_aColors[(Step + I) % 48 / 8];
        //        Color2 = (ushort)_aColors[(Step + I + 8) % 48 / 8];
        //        Color = (ushort)(InterpolateColor(Color1, Color2, 16, (ushort)((Step + I) % 8)) +
        //                 InterpolateColor(Color1, Color2, 8, (ushort)((Step + I) % 8)) +
        //                 InterpolateColor(Color1, Color2, 0, (ushort)((Step + I) % 8)));
        //        msg.AddByte((byte)(Row + I));                  // Pad index
        //        msg.AddByte((byte)((Color >> 17) & 0x7F));   // Red
        //        msg.AddByte((byte)((Color >> 9) & 0x7F));   // Green
        //        msg.AddByte((byte)((Color >> 1) & 0x7F));   // Blue
        //    }
        //    msg.End();
        //    msg.Send();
        //}

        ////    pBitmap   - Pointer to control bytes and bitmap.
        ////    BitmapLen - Length of bitmap payload.
        //static void SendBitmap(byte pBitmap, ushort BitmapLen)
        //{
        //    SysexMessage msg = new SysexMessage();
        //    msg.AddBytes(0x47, 0x7F, 0x43, 0x0E); // AKAI, All-Call, Fire, WRITE OLED
        //    msg.AddByte((byte)(BitmapLen >> 7));    // Payload length high
        //    msg.AddByte((byte)(BitmapLen & 0x7F));  // Payload length low
        //    while (BitmapLen > 0)
        //    {
        //        msg.AddByte(pBitmap++);
        //        --BitmapLen;
        //    }
        //    msg.End(); ;
        //}

        ///*********************************************************************
        //*
        //*       _FIRE_PlotPixel()
        //*
        //*  Function description
        //*    Plot pixel on bitmap.
        //*
        //*  Parameters
        //*    X - X coordinate of pixel (0..127).
        //*    Y - Y coordinate of pixel (0..63).
        //*    C - Color, 0=black, nonzero=white.
        //*/
        //static void _FIRE_PlotPixel(ushort X, ushort Y, ushort C)
        //{
        //    ushort RemapBit;

        //    if (X < 128 && Y < 64)
        //    {
        //        // Unwind 128x64 arrangement into a 1024x8 arrangement of pixels.
        //        X += (ushort)(128 * (Y / 8));
        //        Y %= 8;
        //        // Remap by tiling 7x8 block of translated pixels.
        //        RemapBit = _aBitMutate[Y, X % 7];
        //        if (C > 0)
        //        {
        //            _aOLEDBitmap[4 + X / 7 * 8 + RemapBit / 7] |= (byte)(1u << (RemapBit % 7));
        //        }
        //        else
        //        {
        //            _aOLEDBitmap[4 + X / 7 * 8 + RemapBit / 7] &= (byte)(~(1u << (RemapBit % 7)));
        //        }
        //    }
        //}
    }
}
